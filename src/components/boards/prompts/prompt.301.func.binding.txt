아래의 조건을 모두 적용하여, 아래의 요구사항을 모두 구현할 것.  
구현 결과를 체크리스트로 반환할 것.

==============================================

조건-커서룰) 아래의 커서룰을 적용하여 작업하고, 이 작업이 끝나면 해당 rules 적용 결과를 체크리스트로 반환할 것.  
            - @01-common.mdc
            - @04-func.mdc

==============================================

조건-파일경로) 참고할 API 문서경로: http://main-practice.codebootcamp.co.kr/graphql

조건-파일경로) 참고할 TSX  파일경로: src/components/boards/index.tsx
조건-파일경로) 참고할 CSS  파일경로: src/components/boards/styles.module.css
조건-파일경로) 구현될 HOOK 파일경로: src/components/boards/hooks/index.binding.hook.ts
조건-파일경로) 구현될 TEST 파일경로: src/components/boards/tests/index.binding.hook.spec.ts

==============================================

핵심요구사항) 병렬처리 구현을 위한 작업 방식 조건
            - 다른 채팅에서 개발중인 파일을 수정 및 삭제 하지 말 것.
            - 테스트 충돌을 방지하기 위해, 빌드테스트, 전체테스트를 하지 말 것.

핵심요구사항) 아래의 GraphQL 쿼리를 사용하여 데이터를 불러오는 훅을 구현할 것.
            - 변수
                - endDate: DateTime
                - startDate: DateTime
                - search: String
                - page: Int
            - 실행문
                - query fetchBoards($startDate: DateTime, $endDate: DateTime, $search: String, $page: Int) {
                    fetchBoards(startDate: $startDate, endDate: $endDate, search: $search, page: $page) {
                        _id
                        writer
                        title
                        createdAt
                    }
                }

핵심요구사항) Apollo Client의 useQuery 훅을 사용하여 데이터를 요청할 것.

핵심요구사항) 반환값은 { data, loading, error } 형태로 구성할 것.

핵심요구사항) TypeScript 제네릭을 사용하여 타입 안전성을 확보할 것.

핵심요구사항) 다음의 기능을 playwright의 테스트를 활용하여 TDD기반으로 구현하고, 테스트에 통과할 때 까지 반복할 것.
            1) 테스트 제외 라이브러리
                - jest
                - @testing-library/react

            2) 테스트 조건
                - network 통신이 포함된 테스트의 timeout은 2000ms 미만으로 설정할 것.
                - network 통신이 없는 단순 연산, 렌더링 테스트는 500ms 미만 혹은 timeout 미설정으로 할 것.

            3) 테스트 API 조건
                3-1) 데이터
                - 실제 API 데이터를 사용할 것.
                - Mock데이터, MockedProvider, intercept 등 네트워크 모킹 사용 금지

                3-2) 성공 시나리오
                - 실제 API를 호출해 정상적인 응답을 수신해야 함.
                - Mock 데이터를 모킹하지 말 것.
                - 응답 데이터가 정상적으로 UI에 반영되는 지 검증할 것.

                3-3) 실패 시나리오 
                - 실제 API 호출에서 인증 실패 / 네트워크 오류 등 상황을 재현할 것.
                - Mock 데이터를 사용하거나 에러를 인위적으로 주입하지 말 것.
                - 에러 상태('error' 또는 'catch') 처리 로직이 UI에 반영되는지 검증할 것.

핵심요구사항) 현재의 모든 구조를 그대로 유지하고, 하드코딩된 Mock데이터를 제거하고, 실제 데이터를 바인딩할 것.
            1) 바인딩할 GraphQL 데이터
                - 다음 쿼리를 사용하여 데이터를 불러올 것.
                    - query {
                        fetchBoards(
                            endDate
                            startDate
                            search
                            page
                        ) {
                            _id
                            writer
                            title
                            createdAt
                        }
                    }
                - 쿼리 결과는 `data.fetchBoards` 배열 형태로 반환됨.  
                
            2) 데이터 바인딩 상세 내용
                - boardId: data.fetchBoards 객체의 _id
                    - 현재 게시글 번호로 사용중인 id(게시글 인덱스)는 추후 구현 예정.
                    - 해당 id는 게시글 상세페이지로 라우팅되기위한 boardId로 각 게시글 마다 id 값으로 지정할 것.
                - title: data.fetchBoards 객체의 title
                - author: data.fetchBoards 객체의 writer
                - date: data.fetchBoards 객체의 createdAt => YYYY.MM.DD 로 표현될 수 있도록 날짜 포맷 정규식으로 변경하여 바인딩 할 것.